"""
PDF Tool — Generate and process PDF documents.

Tools provided:
    create_pdf  — Generate branded PDF from HTML content or template
    read_pdf    — Extract text from an uploaded PDF file
    merge_pdfs  — Merge multiple PDF files into one

PDF generation uses WeasyPrint (HTML→PDF with full CSS support) with
ReportLab as a plain-text fallback. Output PDFs are saved to the
configured artifact storage directory.

Mezzofy brand colors: Orange #f97316, Black #000000, White #ffffff.
"""

import logging
import os
import uuid
from pathlib import Path
from typing import Optional

from app.tools.base_tool import BaseTool

logger = logging.getLogger("mezzofy.tools.pdf")

# Default Mezzofy-branded CSS injected into all HTML→PDF conversions
_MEZZOFY_CSS = """
@page {
    size: A4;
    margin: 20mm 15mm 20mm 15mm;
    @bottom-right {
        content: "Page " counter(page) " of " counter(pages);
        font-family: Arial, sans-serif;
        font-size: 9pt;
        color: #666;
    }
}
body {
    font-family: Arial, sans-serif;
    font-size: 11pt;
    color: #1a1a1a;
    line-height: 1.5;
}
h1, h2, h3 { color: #f97316; }
h1 { font-size: 22pt; border-bottom: 2px solid #f97316; padding-bottom: 6pt; }
h2 { font-size: 16pt; }
h3 { font-size: 13pt; }
table { width: 100%; border-collapse: collapse; margin: 12pt 0; }
th { background-color: #f97316; color: white; padding: 8pt 10pt; text-align: left; }
td { padding: 6pt 10pt; border-bottom: 1px solid #e5e7eb; }
tr:nth-child(even) { background-color: #fef3ea; }
.footer-brand { color: #f97316; font-weight: bold; font-size: 9pt; }
"""

_MEZZOFY_HEADER = """
<div style="display:flex; justify-content:space-between; align-items:center;
            border-bottom:3px solid #f97316; padding-bottom:10px; margin-bottom:20px;">
    <div style="font-size:22pt; font-weight:bold; color:#f97316;">Mezzofy</div>
    <div style="font-size:9pt; color:#666;">{document_type}</div>
</div>
"""

_MEZZOFY_FOOTER = """
<div style="margin-top:30px; border-top:1px solid #e5e7eb; padding-top:10px;
            font-size:9pt; color:#666; text-align:center;">
    Generated by <span style="color:#f97316; font-weight:bold;">Mezzofy AI Assistant</span>
</div>
"""


def _get_artifact_dir(config: dict) -> Path:
    """Return artifact storage directory, creating it if needed."""
    base = config.get("storage", {}).get("local_path", "/data/artifacts")
    path = Path(base) / "pdfs"
    path.mkdir(parents=True, exist_ok=True)
    return path


class PDFOps(BaseTool):
    """PDF generation and processing operations."""

    def __init__(self, config: dict):
        super().__init__(config)
        self._artifact_dir = _get_artifact_dir(config)

    def get_tools(self) -> list[dict]:
        return [
            {
                "name": "create_pdf",
                "description": (
                    "Generate a branded Mezzofy PDF document from HTML content or structured data. "
                    "Supports custom titles, document types, and optional CSS styling. "
                    "Returns the file path of the generated PDF."
                ),
                "parameters": {
                    "type": "object",
                    "properties": {
                        "title": {
                            "type": "string",
                            "description": "Document title shown at the top of the PDF.",
                        },
                        "html_content": {
                            "type": "string",
                            "description": "HTML body content to render as PDF.",
                        },
                        "document_type": {
                            "type": "string",
                            "description": (
                                "Document type label (e.g., 'Financial Report', 'Sales Summary', "
                                "'Pitch Deck Summary'). Shown in the header."
                            ),
                            "default": "Report",
                        },
                        "filename": {
                            "type": "string",
                            "description": (
                                "Output filename (without extension). "
                                "Auto-generated if not provided."
                            ),
                        },
                        "extra_css": {
                            "type": "string",
                            "description": "Optional additional CSS to append to the default styles.",
                        },
                    },
                    "required": ["title", "html_content"],
                },
                "handler": self._create_pdf,
            },
            {
                "name": "read_pdf",
                "description": (
                    "Extract text content from an uploaded PDF file. "
                    "Returns structured text with page numbers."
                ),
                "parameters": {
                    "type": "object",
                    "properties": {
                        "file_path": {
                            "type": "string",
                            "description": "Absolute path to the PDF file to read.",
                        },
                        "max_pages": {
                            "type": "integer",
                            "description": "Maximum number of pages to extract (default: all pages).",
                        },
                    },
                    "required": ["file_path"],
                },
                "handler": self._read_pdf,
            },
            {
                "name": "merge_pdfs",
                "description": (
                    "Merge multiple PDF files into a single PDF document. "
                    "Files are merged in the order provided."
                ),
                "parameters": {
                    "type": "object",
                    "properties": {
                        "file_paths": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "List of absolute paths to PDF files to merge.",
                            "minItems": 2,
                        },
                        "output_filename": {
                            "type": "string",
                            "description": "Output filename (without extension) for the merged PDF.",
                        },
                    },
                    "required": ["file_paths"],
                },
                "handler": self._merge_pdfs,
            },
        ]

    async def _create_pdf(
        self,
        title: str,
        html_content: str,
        document_type: str = "Report",
        filename: Optional[str] = None,
        extra_css: Optional[str] = None,
    ) -> dict:
        """Generate a branded PDF from HTML content."""
        if not filename:
            safe_title = "".join(c if c.isalnum() or c in "-_ " else "" for c in title)
            safe_title = safe_title.replace(" ", "_")[:50]
            filename = f"{safe_title}_{uuid.uuid4().hex[:8]}"

        output_path = self._artifact_dir / f"{filename}.pdf"

        css = _MEZZOFY_CSS
        if extra_css:
            css += "\n" + extra_css

        header_html = _MEZZOFY_HEADER.format(document_type=document_type)

        full_html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{title}</title>
    <style>{css}</style>
</head>
<body>
    {header_html}
    <h1>{title}</h1>
    {html_content}
    {_MEZZOFY_FOOTER}
</body>
</html>"""

        try:
            from weasyprint import HTML, CSS
            HTML(string=full_html).write_pdf(str(output_path))
            logger.info(f"Created PDF (WeasyPrint): {output_path}")

        except ImportError:
            logger.warning("WeasyPrint not available, falling back to ReportLab")
            self._create_pdf_reportlab(title, html_content, output_path)

        except Exception as e:
            logger.warning(f"WeasyPrint failed ({e}), falling back to ReportLab")
            self._create_pdf_reportlab(title, html_content, output_path)

        file_size = output_path.stat().st_size if output_path.exists() else 0
        return self._ok({
            "file_path": str(output_path),
            "filename": f"{filename}.pdf",
            "size_bytes": file_size,
            "title": title,
        })

    def _create_pdf_reportlab(self, title: str, html_content: str, output_path: Path) -> None:
        """ReportLab fallback — plain text PDF."""
        from reportlab.lib.pagesizes import A4
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.units import mm
        from reportlab.lib import colors
        from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
        from reportlab.lib.enums import TA_LEFT, TA_CENTER
        import re

        doc = SimpleDocTemplate(
            str(output_path),
            pagesize=A4,
            leftMargin=15 * mm,
            rightMargin=15 * mm,
            topMargin=20 * mm,
            bottomMargin=20 * mm,
        )

        styles = getSampleStyleSheet()
        orange = colors.HexColor("#f97316")

        title_style = ParagraphStyle(
            "MzTitle", parent=styles["Title"],
            textColor=orange, spaceAfter=12,
        )
        heading_style = ParagraphStyle(
            "MzHeading", parent=styles["Heading2"],
            textColor=orange,
        )
        body_style = styles["Normal"]

        # Strip HTML tags for ReportLab plain text
        plain_text = re.sub(r"<[^>]+>", " ", html_content)
        plain_text = re.sub(r"\s+", " ", plain_text).strip()

        story = [
            Paragraph("Mezzofy", title_style),
            Paragraph(title, heading_style),
            Spacer(1, 6 * mm),
            Paragraph(plain_text, body_style),
            Spacer(1, 10 * mm),
            Paragraph(
                '<font color="#f97316">Generated by Mezzofy AI Assistant</font>',
                ParagraphStyle("Footer", parent=styles["Normal"], alignment=TA_CENTER, fontSize=8),
            ),
        ]
        doc.build(story)

    async def _read_pdf(self, file_path: str, max_pages: Optional[int] = None) -> dict:
        """Extract text from a PDF file."""
        if not os.path.exists(file_path):
            return self._err(f"File not found: {file_path}")

        try:
            import pypdf

            reader = pypdf.PdfReader(file_path)
            total_pages = len(reader.pages)
            pages_to_read = total_pages if max_pages is None else min(max_pages, total_pages)

            pages = []
            for i in range(pages_to_read):
                text = reader.pages[i].extract_text() or ""
                pages.append({
                    "page": i + 1,
                    "text": text.strip(),
                })

            return self._ok({
                "file_path": file_path,
                "total_pages": total_pages,
                "pages_extracted": pages_to_read,
                "pages": pages,
            })

        except ImportError:
            return self._err("pypdf is not installed. Run: pip install pypdf")
        except Exception as e:
            logger.error(f"Failed to read PDF {file_path}: {e}")
            return self._err(str(e))

    async def _merge_pdfs(
        self,
        file_paths: list[str],
        output_filename: Optional[str] = None,
    ) -> dict:
        """Merge multiple PDFs into one."""
        for fp in file_paths:
            if not os.path.exists(fp):
                return self._err(f"File not found: {fp}")

        if not output_filename:
            output_filename = f"merged_{uuid.uuid4().hex[:8]}"

        output_path = self._artifact_dir / f"{output_filename}.pdf"

        try:
            import pypdf

            writer = pypdf.PdfWriter()
            total_pages = 0

            for fp in file_paths:
                reader = pypdf.PdfReader(fp)
                for page in reader.pages:
                    writer.add_page(page)
                    total_pages += 1

            with open(output_path, "wb") as f:
                writer.write(f)

            logger.info(f"Merged {len(file_paths)} PDFs → {output_path}")
            return self._ok({
                "file_path": str(output_path),
                "filename": f"{output_filename}.pdf",
                "input_files": len(file_paths),
                "total_pages": total_pages,
                "size_bytes": output_path.stat().st_size,
            })

        except ImportError:
            return self._err("pypdf is not installed. Run: pip install pypdf")
        except Exception as e:
            logger.error(f"Failed to merge PDFs: {e}")
            return self._err(str(e))
