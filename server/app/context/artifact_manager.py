"""
Artifact Manager â€” storage and retrieval of agent-generated files.

Artifacts are files generated by agents (PDFs, PPTX, CSV, DOCX).
They are stored at a configurable path on the server filesystem (EBS in prod)
and tracked in the `artifacts` table for ownership-based access control.

DB table `artifacts`:
  id, user_id, session_id, filename, file_path, file_type, created_at

Download URL pattern: /files/{artifact_id}
"""

import logging
import os
import uuid
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional

from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

logger = logging.getLogger("mezzofy.context.artifacts")

_DEFAULT_ARTIFACTS_DIR = Path("/var/mezzofy/artifacts")


def get_artifacts_dir() -> Path:
    """Return the directory where generated files are stored."""
    env_path = os.getenv("ARTIFACTS_DIR")
    if env_path:
        return Path(env_path)
    return _DEFAULT_ARTIFACTS_DIR


async def register_artifact(
    db: AsyncSession,
    user_id: str,
    session_id: str,
    filename: str,
    file_path: str,
    file_type: str,
) -> dict:
    """
    Register a generated file in the artifacts table.

    The file must already exist at file_path on the filesystem.

    Args:
        db:         Active DB session.
        user_id:    Owner of the artifact.
        session_id: Conversation session that produced this artifact.
        filename:   Display filename (e.g. "sales_report_Q1.pdf").
        file_path:  Absolute path to the file on disk.
        file_type:  MIME-style type string ("pdf", "pptx", "docx", "csv").

    Returns:
        {id, filename, file_type, download_url}
    """
    artifact_id = str(uuid.uuid4())
    now = datetime.now(timezone.utc)

    try:
        await db.execute(
            text(
                """
                INSERT INTO artifacts
                  (id, user_id, session_id, filename, file_path, file_type, created_at)
                VALUES
                  (:id, :uid, :sid, :fname, :fpath, :ftype, :now)
                """
            ),
            {
                "id": artifact_id,
                "uid": user_id,
                "sid": session_id,
                "fname": filename,
                "fpath": file_path,
                "ftype": file_type,
                "now": now,
            },
        )
        logger.debug(f"Registered artifact {artifact_id}: {filename}")
    except Exception as e:
        logger.error(f"Failed to register artifact {filename}: {e}")

    return {
        "id": artifact_id,
        "filename": filename,
        "file_type": file_type,
        "download_url": f"/files/{artifact_id}",
    }


async def get_artifact(
    db: AsyncSession,
    artifact_id: str,
    user_id: str,
) -> Optional[dict]:
    """
    Retrieve artifact metadata. Enforces ownership (user_id must match).

    Returns None if not found or access denied.
    """
    result = await db.execute(
        text(
            """
            SELECT id, filename, file_path, file_type, created_at
            FROM artifacts
            WHERE id = :id AND user_id = :uid
            """
        ),
        {"id": artifact_id, "uid": user_id},
    )
    row = result.fetchone()
    if row is None:
        return None
    return {
        "id": row.id,
        "filename": row.filename,
        "file_path": row.file_path,
        "file_type": row.file_type,
        "download_url": f"/files/{row.id}",
        "created_at": row.created_at.isoformat() if row.created_at else None,
    }


async def list_user_artifacts(
    db: AsyncSession,
    user_id: str,
    limit: int = 50,
    offset: int = 0,
) -> list:
    """List all artifacts belonging to a user (most recent first)."""
    result = await db.execute(
        text(
            """
            SELECT id, filename, file_type, created_at
            FROM artifacts
            WHERE user_id = :uid
            ORDER BY created_at DESC
            LIMIT :lim OFFSET :off
            """
        ),
        {"uid": user_id, "lim": limit, "off": offset},
    )
    return [
        {
            "id": row.id,
            "filename": row.filename,
            "file_type": row.file_type,
            "download_url": f"/files/{row.id}",
            "created_at": row.created_at.isoformat() if row.created_at else None,
        }
        for row in result.fetchall()
    ]
